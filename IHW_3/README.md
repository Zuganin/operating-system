# ИДЗ 3 

## ФИО и группа

**Исполнитель:** Зенин Вадим Вадимович  
**Группа:** БПИ237

---

## Номер варианта и условие задачи

**Вариант:** 4

**Условие задачи:**  
**Задача о Винни-Пухе – 3 или мстительные пчелы.** Непра-
вильные пчелы, подсчитав в конце месяца убытки от наличия в
лесу Винни-Пуха, решили разыскать его и наказать в назидание
всем другим любителям сладкого. Для поисков медведя они поде-
лили лес на участки, каждый из которых прочесывает одна стая
неправильных пчел. В случае нахождения медведя на своем участ-
ке стая проводит показательное наказание и возвращается в улей.
Если участок прочесан, а Винни-Пух на нем не обнаружен, стая
также возвращается в улей. Там она получает информацию об еще
участках, которые еще не исследованы и снова улетает. Или пре-
кращает поиски, узнав, что Винни-Пух наказан.
Создать клиент–серверное приложение, моделирующее по-
ведение пчел.
Каждая стая — отдельный клиент, взаимодействующий с сер-
вером. Сервер обрабатывает поступающие сообщения и передает
их клиентам в соответствии с установленными выше правила-
ми.

---

## Сценарий решаемой задачи

Модель отражает поиск Винни-Пуха в лесу стаями пчел:

- **Сервер** — создает "лес", разделенный на участки и размещает Винни-Пуха в указанном участке. (Массив регионов (интов), где элемент означает находится в нем медведь или нет). Количество регионов и регион, в котором находится Винни-Пух вводятся пользователем при запуске сервера.
- **Клиенты (стаи пчел)** — отдельные процессы, которые:
  - Подключаются к серверу, получают участки для проверки и проверяют полученный участок на наличие Винни-Пуха. (Получают от сервера индекс из массива и элемент, проверяет тот ли самый этот регион и выводят информацию о наказании медведя на консоль, либо обращаются заново к серверу и получают новые данные). Проверка занимает на рандом 1-2 секунды.
  - Номер стаи и номер региона, который она получает, рандомные.
  - Если медведь найден каким-то из клиентов, завершается работа, остальных клиентов и сервера.

---

# 4-5
## Схема взаимодействия процессов

Для реализации взаимодействия между процессами используется **TCP-сокеты**:

- **Сервер** — создает TCP-сокет, принимает подключения и обрабатывает запросы клиентов.
- **Клиенты** — подключаются к серверу и обмениваются сообщениями по протоколу TCP.

### Протокол обмена сообщениями:

1. **От клиента к серверу:**
   - `INIT <ID>` — инициализация стаи с уникальным идентификатором.
   - `FOUND <регион>` — сообщение о нахождении Винни-Пуха в указанном регионе.
   - `NOTFOUND <регион>` — сообщение об отсутствии Винни-Пуха в указанном регионе.

2. **От сервера к клиенту:**
   - `CHECK <регион> <содержит_Винни>` — запрос на проверку региона.
   - `CONFIRM <сообщение>` — подтверждение наказания Винни-Пуха.
   - `DONE <сообщение>` — сообщение о завершении поиска (если Винни-Пух уже найден другой стаей).

### Многопоточная обработка на сервере:

- Каждая стая пчел обрабатывается в отдельном потоке на сервере.
- Используется POSIX-библиотека потоков (pthread) для параллельной обработки подключений.
- Потоки синхронизируют доступ к общим ресурсам (массив леса, флаг нахождения Винни-Пуха).

---

## Обработка завершения

Реализованы два варианта завершения:

1. **Нормальное завершение**: 
   - Происходит после нахождения Винни-Пуха.
   - Все клиенты получают уведомление о завершении и корректно отключаются.
   - Сервер ожидает завершения всех обрабатывающих потоков и освобождает ресурсы.

2. **Завершение по сигналу (Ctrl+C)**:
   - Обрабатывается сигнал `SIGINT` как на клиенте, так и на сервере.
   - Происходит корректное закрытие всех сокетов.
   - Освобождаются выделенные ресурсы.

---

## Очистка ресурсов

В обработчиках завершения предусмотрены следующие операции:

- **На сервере**:
  - Закрытие серверного сокета через `close()`.
  - Освобождение выделенной памяти (`free()`).
  - Установка опции `SO_REUSEADDR` для возможности быстрого повторного использования порта.

- **На клиенте**:
  - Закрытие клиентского сокета через `close()`.
  - Отправка завершающего сообщения, если это возможно.

---

## Пример запуска и результаты работы

### Сервер:
```
[Сервер] ИНИЦИАЛИЗАЦИЯ: Лес имеет 10 регионов. Винни-Пух находится в регионе 7

[Сервер] ЗАПУСК: Сервер запущен на 127.0.0.1:8888. Ожидание стай пчел...
------------------------------------------------------
[Сервер] ПОДКЛЮЧЕНИЕ: Стая пчел подключилась с 127.0.0.1:60240 [Обработчик] ПОДКЛЮЧЕНИЕ: Стая пчел #232 инициализирована
[Обработчик] ПОИСК: Стая пчел #232 сообщает: Регион 6 чист
[Сервер] ПОДКЛЮЧЕНИЕ: Стая пчел подключилась с 127.0.0.1:60242 [Обработчик] ПОДКЛЮЧЕНИЕ: Стая пчел #846 инициализирована
[Обработчик] ПОИСК: Стая пчел #846 сообщает: Регион 4 чист
[Обработчик] ПОИСК: Стая пчел #232 сообщает: Регион 2 чист
[Обработчик] ПОИСК: Стая пчел #846 сообщает: Регион 8 чист
[Обработчик] ПОИСК: Стая пчел #232 сообщает: Регион 1 чист
[Обработчик] ПОИСК: Стая пчел #846 сообщает: Регион 5 чист
[Обработчик] ПОИСК: Стая пчел #232 сообщает: Регион 0 чист
[Обработчик] ПОИСК: Стая пчел #846 сообщает: Регион 3 чист
[Обработчик] ПОИСК: Стая пчел #232 сообщает: Регион 9 чист
[Обработчик] УСПЕХ: Стая пчел #846 сообщает: Винни-Пух найден в регионе 7 и наказан!
[Сервер] ЗАВЕРШЕНИЕ: Сервер завершает работу.

или

[Сервер] ПОДКЛЮЧЕНИЕ: Стая пчел подключилась с 127.0.0.1:60457 [Обработчик] ПОДКЛЮЧЕНИЕ: Стая пчел #737 инициализирована
^C
[Сервер] СИГНАЛ: Получен сигнал завершения (2). Завершаю работу сервера...
[Сервер] ЗАВЕРШЕНИЕ: Сервер успешно завершил работу.
```

### Клиент:
```
[Клиент #846] =========================
[Клиент #846] Подключение: Стая пчел подключилась к улью по адресу 127.0.0.1:8888
[Клиент #846] =========================
[Клиент #846] ПОИСК: Проверяю регион 4 на наличие Винни-Пуха...
[Клиент #846] ОСМОТР: Регион 4 чист, Винни-Пуха здесь нет.
[Клиент #846] ПОИСК: Проверяю регион 8 на наличие Винни-Пуха...
[Клиент #846] ОСМОТР: Регион 8 чист, Винни-Пуха здесь нет.
[Клиент #846] ПОИСК: Проверяю регион 5 на наличие Винни-Пуха...
[Клиент #846] ОСМОТР: Регион 5 чист, Винни-Пуха здесь нет.
[Клиент #846] ПОИСК: Проверяю регион 3 на наличие Винни-Пуха...
[Клиент #846] ОСМОТР: Регион 3 чист, Винни-Пуха здесь нет.
[Клиент #846] ПОИСК: Проверяю регион 7 на наличие Винни-Пуха...
[Клиент #846] НАЙДЕН: Винни-Пух найден в регионе 7! Наказываю Винни-Пуха...
[Клиент #846] УСПЕХ: Винни-Пух наказан
[Клиент #846] ВОЗВРАТ: Задание выполнено! Возвращаюсь в улей.
[Клиент #846] ОТКЛЮЧЕНИЕ: Отключаюсь от сервера.
[Клиент #846] ЗАВЕРШЕНИЕ: Клиент завершил работу. 

или 

[Клиент #232] ПОИСК: Проверяю регион 9 на наличие Винни-Пуха...
[Клиент #232] ОСМОТР: Регион 9 чист, Винни-Пуха здесь нет.
[Клиент #232] УСПЕХ: Винни-Пух был найден другой стаей.
[Клиент #232] ВОЗВРАТ: Завершаю поиск и возвращаюсь в улей.
[Клиент #232] ОТКЛЮЧЕНИЕ: Отключаюсь от сервера.
[Клиент #232] ЗАВЕРШЕНИЕ: Клиент завершил работу.
```

---

# 6-7

## Схема взаимодействия процессов в системе с монитором

Для реализации расширенной системы с дополнительным компонентом-монитором используется **TCP-сокеты**:

Отличие от предыдущего пункта в том, что **Монитор** — новый компонент системы (очень похож на клиента, но отвечает только за логи), который подключается к серверу и получает в реальном времени информацию о всех действиях в системе.

### Расширенный протокол обмена сообщениями:

1. **От клиента к серверу** (без изменений):
   - `INIT <ID>` — инициализация стаи с уникальным идентификатором.
   - `FOUND <регион>` — сообщение о нахождении Винни-Пуха в указанном регионе.
   - `NOTFOUND <регион>` — сообщение об отсутствии Винни-Пуха в указанном регионе.

2. **От сервера к клиенту** (без изменений):
   - `CHECK <регион> <содержит_Винни>` — запрос на проверку региона.
   - `CONFIRM <сообщение>` — подтверждение наказания Винни-Пуха.
   - `DONE <сообщение>` — сообщение о завершении поиска (если Винни-Пух уже найден другой стаей).

3. **Новый протокол взаимодействия с монитором**:
   По факту, это единственное, что добавилось.
   - **От монитора к серверу**:
     - `MONITOR` — идентификация подключения как монитор.
   - **От сервера к монитору**:
     - `[MONITOR] <сообщение>` — все сообщения о событиях с префиксом [MONITOR].

### Архитектура системы:

- **Многопоточная обработка на сервере** (расширенная):
  - Каждый клиент (стая пчел) обрабатывается в отдельном потоке.
  - Мониторы регистрируются в специальном списке для отправки им сообщений.
  - Используется `pthread` для параллельной обработки клиентских подключений.

- **Новые компоненты**:
  - Модуль `HandleTCPMonitor` для идентификации и работы с мониторами.
  - Функции для отправки сообщений всем подключенным мониторам.

---

## Реализация монитора

### Основные особенности монитора:

1. **Идентификация монитора**:
   - При подключении к серверу монитор отправляет специальное сообщение `MONITOR`.
   - Сервер распознает тип клиента и добавляет монитор в специальный массив.

2. **Механизм трансляции сообщений**:
   - Все сообщения о происходящих в системе событиях дублируются всем подключенным мониторам (задатки для некст задания).
   - К каждому сообщению добавляется префикс `[MONITOR]` для визуального отделения в консоли монитора.

3. **Обработка завершения**:
   - Монитор обрабатывает сообщение о нахождении Винни-Пуха и корректно завершает работу.
   - Сервер при завершении закрывает соединения со всеми мониторами.

### Структура кода монитора:

```c
// Основные компоненты monitor.c
void main(int argc, char *argv[]) {
    // 1. Подключение к серверу
    // 2. Отправка идентификационного сообщения MONITOR
    // 3. Вход в цикл получения и отображения сообщений от сервера
    // 4. Обработка завершения при нахождении Винни-Пуха
}
```

---

## Изменения в прошлом пункте 4-5

Для поддержки монитора в существующей системе были внесены следующие изменения:

### 1. Немного изменена структура:
- **Создан новый модуль `HandleTCPMonitor.c` и `HandleTCPMonitor.h`** — для обработки мониторов.
- **Модифицирован `HandleTCPClient.c`** — добавлена поддержка идентификации мониторов и отправки им сообщений.
- **Расширен `server.c`** — добавлена инициализация массива мониторов и их обслуживание.

### 2. Основные дополнения в коде сервера:
- **Массив для хранения сокетов мониторов**: `monitorSockets[MAXMONITORS]`
- **Счетчик подключенных мониторов**: `monitorCount`
- **Новые функции в модуле `HandleTCPMonitor.c`**:
  ```c
  int IsMonitor(char *message);          // Проверка является ли клиент монитором
  void AddMonitor(int socket);           // Добавление нового монитора в список
  void RemoveMonitor(int socket);        // Удаление монитора при отключении
  void SendToMonitors(const char *message); // Отправка сообщения всем мониторам
  ```

### 3. Изменения в обработке клиентов:
- **Добавлена проверка типа клиента**: 
  ```c
  if (IsMonitor(buffer)) {
      AddMonitor(clntSocket);
      return;
  }
  ```

- **Добавлена отправка сообщений мониторам** после каждого значимого действия:
  ```c
  sprintf(monitorMsg, "Стая пчел #%d сообщает: Регион %d чист", swarmID, regionToCheck);
  SendToMonitors(monitorMsg);
  ```

### 4. Изменения в обработке завершения:
- **Модифицирован обработчик сигналов** для уведомления мониторов о завершении работы сервера:
  ```c
  SendToMonitors("Сервер завершает работу по сигналу");
  ```

- **Добавлено закрытие сокетов мониторов** при завершении работы сервера:
  ```c
  for (int i = 0; i < monitorCount; i++) {
      close(monitorSockets[i]);
  }
  ```

---

## Пример работы системы с монитором

### Сервер:
```
[Сервер] ИНИЦИАЛИЗАЦИЯ: Лес имеет 10 регионов. Винни-Пух находится в регионе 5

[Сервер] ЗАПУСК: Сервер запущен на 127.0.0.1:9999. Ожидание стай пчел...
------------------------------------------------------
[Сервер] ПОДКЛЮЧЕНИЕ: Стая пчел подключилась с 127.0.0.1:63981
[Сервер] МОНИТОРИНГ: Новый монитор подключен (сокет: 4)
[Сервер] ПОДКЛЮЧЕНИЕ: Стая пчел подключилась с 127.0.0.1:63993
[Обработчик] ПОДКЛЮЧЕНИЕ: Стая пчел #195 инициализирована
[Обработчик] ПОИСК: Стая пчел #195 сообщает: Регион 7 чист
[Обработчик] ПОИСК: Стая пчел #195 сообщает: Регион 9 чист
[Обработчик] УСПЕХ: Стая пчел #195 сообщает: Винни-Пух найден в регионе 5 и наказан!
[Сервер] ЗАВЕРШЕНИЕ: Сервер завершает работу.
```

### Клиент:
```
[Клиент #195] =========================
[Клиент #195] Подключение: Стая пчел подключилась к улью по адресу 127.0.0.1:9999
[Клиент #195] =========================
[Клиент #195] ПОИСК: Проверяю регион 7 на наличие Винни-Пуха...
[Клиент #195] ОСМОТР: Регион 7 чист, Винни-Пуха здесь нет.
[Клиент #195] ПОИСК: Проверяю регион 9 на наличие Винни-Пуха...
[Клиент #195] ОСМОТР: Регион 9 чист, Винни-Пуха здесь нет.
[Клиент #195] ПОИСК: Проверяю регион 5 на наличие Винни-Пуха...
[Клиент #195] НАЙДЕН: Винни-Пух найден в регионе 5! Наказываю Винни-Пуха...
[Клиент #195] УСПЕХ: Винни-Пух наказан
[Клиент #195] ВОЗВРАТ: Задание выполнено! Возвращаюсь в улей.
[Клиент #195] ОТКЛЮЧЕНИЕ: Отключаюсь от сервера.
[Клиент #195] ЗАВЕРШЕНИЕ: Клиент завершил работу.
```

### Монитор:
```
[Монитор] =========================
[Монитор] Подключение: Монитор подключился к серверу по адресу 127.0.0.1:9999
[Монитор] =========================
[Монитор] Отправлено приветственное сообщение серверу
[Монитор] Ожидание данных мониторинга...
[MONITOR] Стая пчел подключилась с 127.0.0.1:63993
[MONITOR] Стая пчел #195 инициализирована
[MONITOR] Стае #195 отправлен запрос на проверку региона 7
[MONITOR] Стая пчел #195 сообщает: Регион 7 чист
[MONITOR] Стае #195 отправлен запрос на проверку региона 9
[MONITOR] Стая пчел #195 сообщает: Регион 9 чист
[MONITOR] Стае #195 отправлен запрос на проверку региона 5
[MONITOR] УСПЕХ: Стая пчел #195 сообщает: Винни-Пух найден в регионе 5 и наказан!
[Монитор] ЗАВЕРШЕНИЕ: Винни-Пух найден, завершаем работу монитора
[Монитор] ОТКЛЮЧЕНИЕ: Отключаюсь от сервера.
[Монитор] ЗАВЕРШЕНИЕ: Монитор завершил работу.
```

---

# 8

## Модернизация системы мониторинга и поддержка множественных мониторов

### Алгоритм работы с множественными мониторами

В системе реализована поддержка одновременного подключения нескольких мониторов, что позволяет нескольким наблюдателям отслеживать процесс поиска Винни-Пуха. Ниже описан алгоритм работы этой подсистемы:

#### 1. Регистрация мониторов

- **Выделение ресурсов**: Система резервирует массив для хранения до 10 подключений мониторов:
  ```c
  #define MAXMONITORS 10
  int monitorSockets[MAXMONITORS];
  int monitorCount = 0;
  ```

- **Идентификация мониторов при подключении**:
  1. Когда новое соединение устанавливается, сервер не знает, является ли оно стаей пчел или монитором
  2. Сервер получает первое сообщение от клиента и проверяет его содержимое:
     ```c
     if (IsMonitor(buffer)) {
         AddMonitor(clntSocket);
         return;
     }
     ```
  3. Если сообщение содержит строку "MONITOR", клиент идентифицируется как монитор и добавляется в список мониторов

- **Регистрация в системе**:
  ```c
  void AddMonitor(int socket) {
      if (monitorCount < MAXMONITORS) {
          monitorSockets[monitorCount++] = socket;
          printf("[Сервер] МОНИТОРИНГ: Новый монитор подключен (сокет: %d)\n", socket);
      } else {
          // Если превышен лимит, отклоняем подключение
          close(socket);
      }
  }
  ```

#### 2. Механизм трансляции сообщений

- **Отправка сообщений всем мониторам**:
  1. При каждом значимом событии в системе вызывается функция `SendToMonitors()`
  2. Функция выполняет фильтрацию сообщений, связанных с мониторингом
  3. Форматирует сообщение с префиксом "[Монитор]"
  4. Отправляет сообщение каждому подключенному монитору:
     ```c
     for (int i = 0; i < monitorCount; i++) {
         int result = send(monitorSockets[i], monitorMessage, strlen(monitorMessage), MSG_NOSIGNAL);
         // Проверка результата и обработка ошибок
     }
     ```

- **Независимая работа мониторов**:
  - Каждый монитор работает в своем собственном процессе
  - Мониторы получают одинаковую информацию, но могут отображать ее по-разному
  - Подключение или отключение любого монитора не влияет на работу остальных мониторов или клиентов

#### 3. Обработка отключений и ошибок

- **Автоматическое обнаружение отключения**:
  ```c
  if (result <= 0) {
      printf("[Сервер] МОНИТОРИНГ: Монитор отключен (сокет: %d) - обнаружено при отправке сообщения\n", monitorSockets[i]);
      RemoveMonitor(monitorSockets[i]);
      i--; // Корректируем счетчик после удаления элемента из массива
  }
  ```

- **Удаление из системы**:
  ```c
  void RemoveMonitor(int socket) {
      for (int i = 0; i < monitorCount; i++) {
          if (monitorSockets[i] == socket) {
              // Смещаем все элементы после удаляемого
              for (int j = i; j < monitorCount - 1; j++) {
                  monitorSockets[j] = monitorSockets[j + 1];
              }
              monitorCount--;
              break;
          }
      }
  }
  ```

- **Обработка системных ошибок**:
  - Использование флага `MSG_NOSIGNAL` для предотвращения сигнала SIGPIPE при записи в закрытый сокет
  - Поддержка кросс-платформенности через определение флага для macOS:
    ```c
    #ifndef MSG_NOSIGNAL
    #define MSG_NOSIGNAL 0
    #endif
    ```

#### 4. Фильтрация сообщений

- **Предотвращение циклической отправки**:
  ```c
  static int IsMonitorRelatedMessage(const char *message) {
      return (strstr(message, "монитор") != NULL || 
              strstr(message, "Монитор") != NULL);
  }
  
  if (IsMonitorRelatedMessage(message)) {
      return; // Пропускаем сообщения, связанные с мониторами
  }
  ```

- **Обеспечение единого формата**:
  - Удаление символов перевода строки из исходного сообщения
  - Добавление единого форматирования для всех сообщений
  - Контроль переполнения буфера через `snprintf`

#### 5. Завершение работы системы

- **Корректное завершение мониторов**:
  1. При завершении работы (найден Винни-Пух или получен сигнал) сервер отправляет уведомление всем мониторам:
     ```c
     SendToMonitors("Сервер завершает работу по сигналу");
     ```
  2. Монитор обнаруживает сообщение о завершении и завершает свою работу:
     ```c
     if (strstr(buffer, "Сервер завершает работу")) {
         printf("[Монитор] ЗАВЕРШЕНИЕ: Сервер завершил работу, отключаюсь\n");
         break;
     }
     ```
  3. Сервер закрывает все соединения с мониторами:
     ```c
     for (int i = 0; i < monitorCount; i++) {
         if (monitorSockets[i] >= 0) {
             close(monitorSockets[i]);
         }
     }
     ```

### Схема взаимодействия компонентов системы с множественными мониторами

```
                ┌──────────────┐
                │   МОНИТОР 1  │◄────┐
                └───────┬──────┘     │
                        │           │
                        ▼           │
┌──────────┐    ┌──────────────┐    │    ┌──────────┐
│ КЛИЕНТ 1 │◄──►│              │◄───┼────┤ МОНИТОР 2│
└──────────┘    │              │    │    └──────────┘
                │              │    │
┌──────────┐    │    СЕРВЕР    │    │    ┌──────────┐
│ КЛИЕНТ 2 │◄──►│              │◄───┼────┤ МОНИТОР 3│
└──────────┘    │              │    │    └──────────┘
                │              │    │
┌──────────┐    │              │    │    ┌──────────┐
│ КЛИЕНТ N │◄──►│              │◄───┴────┤ МОНИТОР M│
└──────────┘    └──────────────┘         └──────────┘
```



### Выводы (Вкратце)

Ну в принципе почти, ничего не поменялось по сравнению с предыдущим пунктом, посколько была использована наработка с массивом сокетов. Был немного скорректирован процесс логирования, поскольку предполагается, что данную систему можно запускать на отдельных компьютерах, то мне кажется, что монитор должен показывать в основном работу клиентов и их общение с сервером. А такие моменты как подключение/отключение монитора к серверу, более глубокая техническая часть, которая отображается только на сервере, поэтому разные мониторы показывают одни и те же логи. А так программа, также как и ранее поддерживает завершение через `SIGINT` как одного клиента, так и одного монитора, и завершение работы сервера в целом. Ну и как раньше после обнаружения и публичного наказания бедного Винни-Пуха, завершается работа клиентов, мониторов и системы в целом. 
